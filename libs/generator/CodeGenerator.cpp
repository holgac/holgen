#include "CodeGenerator.h"

#include <holgen.h>
#include <sstream>
#include "HeaderContainer.h"
#include "generators/CMakeGenerator.h"
#include "generators/HolgenHeaderGenerator.h"
#include "generators/CppModifiableSourceGenerator.h"
#include "generators/CppHeaderGenerator.h"

namespace holgen {
namespace {
const char *GenMessage = "This file is generated by holgen. Do not modify manually.";
} // namespace

namespace {
bool CanBeDefinedInHeader(const Class &cls, const MethodBase &method) {
  return !method.mTemplateParameters.empty() || !cls.mTemplateParameters.empty() ||
      !cls.mTemplateSpecializations.empty() || method.mDefaultDelete != DefaultDelete::Neither;
}

bool CanBeDefinedInHeader(const Class &cls, const ClassMethod &method) {
  return CanBeDefinedInHeader(cls, (const MethodBase &)method) ||
      method.mConstexprness == Constexprness::Constexpr;
}

template <typename C>
std::string StringifyTemplateParameters(const C &templateParameters) {
  std::stringstream ss;
  ss << "template <";
  bool isFirst = true;
  for (const auto &templateParameter: templateParameters) {
    if (isFirst) {
      isFirst = false;
    } else {
      ss << ", ";
    }
    ss << templateParameter.mType << " " << templateParameter.mName;
  }
  ss << ">";
  return ss.str();
}

std::string StringifyFieldDefinition(const ClassField &field) {
  std::stringstream ss;
  if (!field.mDefaultConstructorArguments.empty()) {
    ss << "(";
    bool isFirst = true;
    for (auto &ctorArg: field.mDefaultConstructorArguments) {
      if (isFirst)
        isFirst = false;
      else
        ss << ", ";
      ss << ctorArg;
    }
    ss << ")";
  } else if (field.mDefaultValue.has_value()) {
    ss << " = " << *field.mDefaultValue;
  }
  return ss.str();
}
} // namespace

std::vector<GeneratedContent> CodeGenerator::Generate(const TranslatedProject &translatedProject) {
  mTranslatedProject = &translatedProject;
  std::vector<GeneratedContent> contents;
  for (auto &cls: translatedProject.mClasses) {
    auto headerHeaders = PrepareIncludes(cls, true);
    auto sourceHeaders = PrepareIncludes(cls, false);
    sourceHeaders.Subtract(headerHeaders);
    GenerateClassSource(contents.emplace_back(), cls, sourceHeaders);
  }
  CppHeaderGenerator(mGeneratorSettings, translatedProject).Run(contents);
  CppModifiableSourceGenerator(mGeneratorSettings, translatedProject).Run(contents);
  HolgenHeaderGenerator(mGeneratorSettings, translatedProject).Run(contents);
  CMakeGenerator(mGeneratorSettings, translatedProject).Run(contents);

  if (mGeneratorSettings.IsFeatureEnabled(GeneratorFeatureFlag::SwigMask)) {
    GenerateSwigInterface(contents.emplace_back(), translatedProject);
  }

  mTranslatedProject = nullptr;

  return contents;
}

CodeBlock CodeGenerator::GenerateDestructor(const Class &cls, Visibility visibility,
                                            bool isHeader) const {
  CodeBlock codeBlock;
  if (cls.mDestructor.IsEmpty() || (isHeader && cls.mDestructor.mVisibility != visibility))
    return {};
  bool definedInHeader = CanBeDefinedInHeader(cls, cls.mDestructor);
  std::string virtualPrefix = cls.HasVirtualMethods() ? "virtual " : "";
  if (isHeader) {
    if (!definedInHeader) {
      codeBlock.Add("{}~{}();", virtualPrefix, cls.mName);
    } else if (cls.mDestructor.mDefaultDelete == DefaultDelete::Default) {
      codeBlock.Add("{}~{}() = default;", virtualPrefix, cls.mName);
    } else if (cls.mDestructor.mDefaultDelete == DefaultDelete::Delete) {
      codeBlock.Add("{}~{}() = delete;", virtualPrefix, cls.mName);
    } else {
      if (isHeader) {
        codeBlock.Add("{}~{}() {{", virtualPrefix, cls.mName);
      } else {
        codeBlock.Add("~{}() {{", cls.mName);
      }
      codeBlock.Indent(1);
      codeBlock.Add(cls.mDestructor.mBody);
      codeBlock.Indent(-1);
      codeBlock.Add("}}");
    }
  } else if (!definedInHeader) {
    codeBlock.Add("{0}::~{0}() {{", cls.mName);
    codeBlock.Indent(1);
    codeBlock.Add(cls.mDestructor.mBody);
    codeBlock.Indent(-1);
    codeBlock.Add("}}");
  }
  return codeBlock;
}

void CodeGenerator::GenerateSwigInterface(GeneratedContent &swig,
                                          const TranslatedProject &translatedProject) const {
  swig.mType = FileType::SwigInterface;
  swig.mName = std::format("swig.i", mGeneratorSettings.mProjectName);
  CodeBlock includes;
  CodeBlock body;
  for (auto &cls: translatedProject.mClasses) {
    if (cls.mStruct) {
      GenerateSwigInterfaceIncludes(cls, includes);
      GenerateSwigInterfaceForStruct(cls, body);
    } else if (cls.mEnum) {
      GenerateSwigInterfaceIncludes(cls, includes);
      GenerateSwigInterfaceForEnum(cls, body);
    }
  }
  swig.mBody.Add("%module {}", mGeneratorSettings.mProjectName);
  swig.mBody.Add("%{{", mGeneratorSettings.mProjectName);
  swig.mBody.Add(std::move(includes));
  swig.mBody.Add("%}}", mGeneratorSettings.mProjectName);
  swig.mBody.Add(std::move(body));
}

void CodeGenerator::GenerateSwigInterfaceIncludes(const Class &cls, CodeBlock &codeBlock) const {
  codeBlock.Add("#include \"../gen/{}.h\"", cls.mName);
}

void CodeGenerator::GenerateSwigInterfaceForStruct(const Class &cls, CodeBlock &codeBlock) const {
  codeBlock.Add("class {} {{", cls.mName);
  codeBlock.Add("public:");
  codeBlock.Indent(1);
  for (auto &ctor: cls.mConstructors) {
    if (ctor.mVisibility == Visibility::Public)
      codeBlock.Add("{};", GenerateFunctionSignature(cls, ctor, true, true));
  }
  // dtor
  codeBlock.Add("~{}();", cls.mName);
  for (auto &method: cls.mMethods) {
    if (method.mVisibility == Visibility::Public)
      codeBlock.Add("{};", GenerateFunctionSignature(cls, method, true, true));
  }
  codeBlock.Indent(-1);
  codeBlock.Add("}};");
}

void CodeGenerator::GenerateSwigInterfaceForEnum(const Class &cls, CodeBlock &codeBlock) const {
  codeBlock.Add("class {} {{", cls.mName);
  codeBlock.Add("public:");
  codeBlock.Indent(1);
  {
    auto line = codeBlock.Line();
    line << "enum {";
    auto &enumDefinition = *cls.mEnum;
    bool isFirst = true;
    for (auto &entry: enumDefinition.mEntries) {
      if (isFirst) {
        isFirst = false;
      } else {
        line << ", ";
      }
      line << entry.mName << "=" << entry.mValue;
    }
    line << "};";
  }
  codeBlock.Indent(-1);
  codeBlock.Add("}};");
}

void CodeGenerator::GenerateClassSource(GeneratedContent &source, const Class &cls,
                                        const HeaderContainer &headers) const {
  source.mType = FileType::CppSource;
  source.mName = std::format("gen/{}.cpp", cls.mName);
  CodeBlock codeBlock;
  codeBlock.Add("// {}", GenMessage);
  codeBlock.Add("#include \"{}.h\"", cls.mName);
  codeBlock.Line();
  headers.Write(codeBlock);

  if (!cls.mNamespace.empty())
    codeBlock.Add("namespace {} {{", cls.mNamespace);

  bool previousBlockWasEmpty = true;
  {
    auto block = GenerateFieldsForSource(cls);
    codeBlock.Add(std::move(block));
    previousBlockWasEmpty = block.mContents.empty();
  }

  {
    auto block = GenerateConstructorsForSource(cls);
    if (!block.mContents.empty()) {
      if (!previousBlockWasEmpty)
        codeBlock.AddLine();
      codeBlock.Add(std::move(block));
      previousBlockWasEmpty = false;
    }
  }

  {
    auto block = GenerateDestructor(cls);
    if (!block.mContents.empty()) {
      if (!previousBlockWasEmpty)
        codeBlock.AddLine();
      codeBlock.Add(std::move(block));
    }
  }

  {
    auto block = GenerateMethodsForSource(cls);
    if (!block.mContents.empty()) {
      if (!previousBlockWasEmpty)
        codeBlock.AddLine();
      codeBlock.Add(std::move(block));
    }
  }

  if (!cls.mNamespace.empty())
    codeBlock.Add("}}"); // namespace

  GenerateCFunctionsForSource(codeBlock, cls);

  source.mBody = std::move(codeBlock);
}

CodeBlock CodeGenerator::GenerateFieldsForSource(const Class &cls) const {
  CodeBlock codeBlock;
  for (auto &field: cls.mFields) {
    if (field.mStaticness == Staticness::Static && field.mType.mName == cls.mName) {
      codeBlock.Add("{}{}::{}{};", field.mType.ToString(false), cls.mName, field.mName,
                    StringifyFieldDefinition(field));
    }
  }
  return codeBlock;
}

CodeBlock CodeGenerator::GenerateMethodsForSource(const Class &cls) const {
  CodeBlock codeBlock;
  if (!cls.mTemplateParameters.empty())
    return {};

  bool isFirstMethod = true;

  for (auto &method: cls.mMethods) {
    if (CanBeDefinedInHeader(cls, method) || method.mUserDefined) {
      continue;
    }
    if (isFirstMethod)
      isFirstMethod = false;
    else
      codeBlock.AddLine();
    if (method.mIsTemplateSpecialization) {
      codeBlock.Add("template <>");
    }
    codeBlock.Line() << GenerateFunctionSignature(cls, method, false, false) << " {";
    codeBlock.Indent(1);
    codeBlock.Add(method.mBody);
    codeBlock.Indent(-1);
    codeBlock.Add("}}");
  }
  return codeBlock;
}

HeaderContainer CodeGenerator::PrepareIncludes(const Class &cls, bool isHeader) const {
  HeaderContainer headers;
  if (isHeader)
    headers = cls.mHeaderIncludes;
  else
    headers = cls.mSourceIncludes;

  if (isHeader) {
    for (auto &baseClass: cls.mBaseClasses) {
      headers.IncludeBaseClass(*mTranslatedProject, cls, baseClass);
    }
  }

  for (const auto &field: cls.mFields) {
    headers.IncludeClassField(*mTranslatedProject, cls, field, isHeader);
  }
  for (const auto &method: cls.mMethods) {
    headers.IncludeClassMethod(*mTranslatedProject, cls, method, isHeader);
  }
  for (const auto &usingStatement: cls.mUsings) {
    headers.IncludeUsing(*mTranslatedProject, usingStatement, isHeader);
  }
  return headers;
}

CodeBlock CodeGenerator::GenerateConstructorsForSource(const Class &cls) const {
  CodeBlock codeBlock;
  if (!cls.mTemplateParameters.empty())
    return {};
  bool isFirstMethod = true;

  for (auto &ctor: cls.mConstructors) {
    if (!ctor.mTemplateParameters.empty() || ctor.mDefaultDelete != DefaultDelete::Neither) {
      // These are defined in the header
      continue;
    }

    if (ctor.mUserDefined) {
      continue;
    }

    if (isFirstMethod)
      isFirstMethod = false;
    else
      codeBlock.AddLine();
    if (ctor.mIsTemplateSpecialization) {
      codeBlock.Add("template <>");
    }
    {
      auto line = codeBlock.Line();
      line << GenerateFunctionSignature(cls, ctor, false, false);
      if (ctor.mInitializerList.empty())
        line << " {";
      else
        line << " :";
    }
    if (!ctor.mInitializerList.empty()) {
      codeBlock.Indent(2);
      {
        auto line = codeBlock.Line();
        bool isFirst = true;
        for (auto &iElem: ctor.mInitializerList) {
          if (isFirst)
            isFirst = false;
          else
            line << ", ";
          line << iElem.mDestination << "(" << iElem.mValue << ")";
        }
        line << " {";
      }
      codeBlock.Indent(-2);
    }
    codeBlock.Indent(1);
    codeBlock.Add(ctor.mBody);
    codeBlock.Indent(-1);
    codeBlock.Line() << "}";
  }
  return codeBlock;
}

void CodeGenerator::GenerateCFunctionsForSource(CodeBlock &codeBlock, const Class &cls) const {
  if (cls.mCFunctions.empty())
    return;
  codeBlock.Add("extern \"C\" {{");
  codeBlock.Indent(1);
  for (auto &func: cls.mCFunctions) {
    codeBlock.Add("{} {{", GenerateFunctionSignature(func, false));
    codeBlock.Indent(1);
    codeBlock.Add(func.mBody);
    codeBlock.Indent(-1);
    codeBlock.Add("}}");
  }
  codeBlock.Indent(-1);
  codeBlock.Add("}}");
}

std::string CodeGenerator::GenerateFunctionSignature(const Class &cls, const ClassMethod &method,
                                                     bool isInHeader, bool isInsideClass) const {
  std::stringstream ss;
  if (method.mConstexprness == Constexprness::Constexpr)
    ss << "constexpr ";
  if (method.mStaticness == Staticness::Static && isInsideClass && isInHeader)
    ss << "static ";
  if (isInHeader && isInsideClass && method.mVirtuality != Virtuality::NotVirtual) {
    ss << "virtual ";
  }
  // TODO: this doesn't work if type is const
  if (!isInHeader && cls.GetUsing(method.mReturnType.mName))
    ss << cls.mName << "::";
  ss << method.mReturnType.ToString(false);
  if (!isInHeader || !isInsideClass)
    ss << cls.mName << "::";
  ss << method.mName << "(";
  size_t idx = 0;
  for (auto &arg: method.mArguments) {
    if (idx != 0)
      ss << ", ";
    ss << arg.mType.ToString(false) << arg.mName;
    if (isInHeader && arg.mDefaultValue.has_value())
      ss << " = " << *arg.mDefaultValue;
    ++idx;
  }
  ss << ")";
  if (method.mConstness == Constness::Const)
    ss << " const";
  if (method.mNoexceptness == Noexceptness::Noexcept)
    ss << " noexcept";
  return ss.str();
}

std::string CodeGenerator::GenerateFunctionSignature(const Class &cls, const ClassConstructor &ctor,
                                                     bool isInHeader, bool isInsideClass) const {
  std::stringstream ss;
  if (isInHeader && isInsideClass && ctor.mExplicitness == Explicitness::Explicit)
    ss << "explicit ";
  if (!isInsideClass)
    ss << cls.mName << "::";
  ss << cls.mName << "(";
  bool isFirst = true;
  for (auto &arg: ctor.mArguments) {
    if (isFirst)
      isFirst = false;
    else
      ss << ", ";
    // TODO: this doesn't work if type is const
    if (cls.GetUsing(arg.mType.mName) && !isInsideClass)
      ss << cls.mName << "::";
    ss << arg.mType.ToString(false) << arg.mName;
    if (isInsideClass && arg.mDefaultValue.has_value()) {
      ss << " = " << *arg.mDefaultValue;
    }
  }
  ss << ")";
  if (ctor.mNoexceptness == Noexceptness::Noexcept)
    ss << " noexcept";
  return ss.str();
}

std::string CodeGenerator::GenerateFunctionSignature(const CFunction &func, bool isInHeader) const {

  std::stringstream ss;
  if (isInHeader) {
    ss << "HOLGEN_EXPORT ";
  }
  ss << func.mReturnType.ToFullyQualifiedString(*mTranslatedProject);

  ss << func.mName << "(";
  size_t idx = 0;
  for (auto &arg: func.mArguments) {
    if (idx != 0)
      ss << ", ";
    ss << arg.mType.ToFullyQualifiedString(*mTranslatedProject) << arg.mName;
    ++idx;
  }
  ss << ")";
  return ss.str();
}

} // namespace holgen
