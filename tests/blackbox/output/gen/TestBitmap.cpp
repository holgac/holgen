// This file is generated by holgen. Do not modify manually.
#include "TestBitmap.h"

#include <sstream>
#include <rapidjson/document.h>
#include "Converter.h"
#include "JsonHelper.h"
#include "LuaHelper.h"

namespace holgen_blackbox_test {
TestBitmap::TestBitmap(TestBitmap::UnderlyingType value) :
    mValue(UnderlyingType(value)) {
}

TestBitmap::UnderlyingType TestBitmap::GetValue() const {
  return mValue;
}

TestBitmap TestBitmap::FromStringSingle(std::string_view str) {
  if (str == "Entry1") {
    return TestBitmap(TestBitmap::Entry1);
  } else if (str == "Entry2") {
    return TestBitmap(TestBitmap::Entry2);
  } else if (str == "Entry3") {
    return TestBitmap(TestBitmap::Entry3);
  } else if (str == "Entry4") {
    return TestBitmap(TestBitmap::Entry4);
  } else if (str == "Entry5") {
    return TestBitmap(TestBitmap::Entry5);
  } else {
    HOLGEN_WARN("{} is not a valid TestBitmap, returning invalid", str);
    return TestBitmap{};
  }
}

TestBitmap TestBitmap::FromString(std::string_view str) {
  TestBitmap result;
  size_t curIdx = 0, commaIdx = str.find(',');
  while (commaIdx != std::string::npos) {
    result |= TestBitmap::FromStringSingle(str.substr(curIdx, commaIdx - curIdx));
    curIdx = commaIdx + 1;
    commaIdx = str.find(',', curIdx);
  }
  result |= TestBitmap::FromStringSingle(str.substr(curIdx));
  return result;
}

const char *TestBitmap::ToStringSingle() const {
  switch (mValue) {
    case TestBitmap::Entry1:
      return "Entry1";
    case TestBitmap::Entry2:
      return "Entry2";
    case TestBitmap::Entry3:
      return "Entry3";
    case TestBitmap::Entry4:
      return "Entry4";
    case TestBitmap::Entry5:
      return "Entry5";
    default:
      return "INVALID";
  }
}

std::string TestBitmap::ToString() const {
  std::stringstream ss;
  bool isFirst = true;
  for (auto& entry: GetEntries()) {
    if (Has(entry)) {
      if (isFirst) {
        isFirst = false;
      } else {
        ss << ",";
      }
      ss << TestBitmap(entry).ToStringSingle();
    }
  }
  return ss.str();
}

TestBitmap &TestBitmap::operator=(UnderlyingType rhs) {
  mValue = rhs;
  return *this;
}

bool TestBitmap::operator==(UnderlyingType rhs) const {
  return mValue == rhs;
}

bool TestBitmap::operator==(const TestBitmap &rhs) const {
  return mValue == rhs.mValue;
}

bool TestBitmap::operator!=(UnderlyingType rhs) const {
  return mValue != rhs;
}

bool TestBitmap::operator!=(const TestBitmap &rhs) const {
  return mValue != rhs.mValue;
}

bool TestBitmap::operator<(UnderlyingType rhs) const {
  return mValue < rhs;
}

bool TestBitmap::operator<(const TestBitmap &rhs) const {
  return mValue < rhs.mValue;
}

TestBitmap &TestBitmap::operator|=(TestBitmap::Entry rhs) {
  mValue |= rhs;
  return *this;
}

TestBitmap &TestBitmap::operator|=(const TestBitmap &rhs) {
  mValue |= rhs.mValue;
  return *this;
}

TestBitmap &TestBitmap::operator|=(UnderlyingType rhs) {
  mValue |= rhs;
  return *this;
}

bool TestBitmap::operator|(const TestBitmap &rhs) const {
  return mValue | rhs.mValue;
}

bool TestBitmap::operator|(TestBitmap::Entry rhs) const {
  return mValue | rhs;
}

TestBitmap &TestBitmap::operator&=(TestBitmap::Entry rhs) {
  mValue &= rhs;
  return *this;
}

TestBitmap &TestBitmap::operator&=(const TestBitmap &rhs) {
  mValue &= rhs.mValue;
  return *this;
}

TestBitmap &TestBitmap::operator&=(UnderlyingType rhs) {
  mValue &= rhs;
  return *this;
}

bool TestBitmap::operator&(const TestBitmap &rhs) const {
  return mValue & rhs.mValue;
}

bool TestBitmap::operator&(TestBitmap::Entry rhs) const {
  return mValue & rhs;
}

TestBitmap &TestBitmap::operator^=(TestBitmap::Entry rhs) {
  mValue ^= rhs;
  return *this;
}

TestBitmap &TestBitmap::operator^=(const TestBitmap &rhs) {
  mValue ^= rhs.mValue;
  return *this;
}

TestBitmap &TestBitmap::operator^=(UnderlyingType rhs) {
  mValue ^= rhs;
  return *this;
}

bool TestBitmap::operator^(const TestBitmap &rhs) const {
  return mValue ^ rhs.mValue;
}

bool TestBitmap::operator^(TestBitmap::Entry rhs) const {
  return mValue ^ rhs;
}

bool TestBitmap::Has(const TestBitmap &val) const {
  return (mValue & val.mValue) == val.mValue;
}

void TestBitmap::Add(const TestBitmap &val) {
  mValue |= val.mValue;
}

void TestBitmap::Remove(const TestBitmap &val) {
  mValue &= ~(val.mValue);
}

void TestBitmap::Toggle(const TestBitmap &val) {
  mValue ^= val.mValue;
}

bool TestBitmap::Has(const TestBitmap::Entry &val) const {
  return (mValue & val) == val;
}

void TestBitmap::Add(const TestBitmap::Entry &val) {
  mValue |= val;
}

void TestBitmap::Remove(const TestBitmap::Entry &val) {
  mValue &= ~(val);
}

void TestBitmap::Toggle(const TestBitmap::Entry &val) {
  mValue ^= val;
}

bool TestBitmap::ParseJson(const rapidjson::Value &json, const Converter &converter, lua_State *luaState) {
  if (json.IsString()) {
    *this = TestBitmap::FromString(std::string_view(json.GetString(), json.GetStringLength()));
  } else if (json.IsInt64()) {
    *this = TestBitmap(json.GetInt64());
  } else if (json.IsArray()) {
    for (auto &data: json.GetArray()) {
      TestBitmap parsedData;
      parsedData.ParseJson(data, converter, luaState);
      Add(parsedData);
    }
  } else {
    *this = TestBitmap{};
    HOLGEN_WARN("Could not json-parse TestBitmap enum: invalid json type");
    return false;
  }
  return true;
}

rapidjson::Value TestBitmap::DumpJson(rapidjson::Document &doc, lua_State *luaState) const {
  return rapidjson::Value(GetValue());
}

void TestBitmap::PushToLua(lua_State *luaState) const {
  LuaHelper::Push<true>(mValue, luaState);
}

void TestBitmap::PushMirrorToLua(lua_State *luaState) const {
  LuaHelper::Push<true>(mValue, luaState);
}

TestBitmap TestBitmap::ReadMirrorFromLua(lua_State *luaState, int32_t idx) {
  auto typ = lua_type(luaState, idx);
  if (typ == LUA_TSTRING) {
    return FromString(lua_tostring(luaState, idx));
  } else if (typ == LUA_TNUMBER) {
    return TestBitmap(lua_tonumber(luaState, idx));
  } else {
    HOLGEN_WARN("Unexpected type when parsing TestBitmap: {}", lua_typename(luaState, typ));
    return TestBitmap{};
  }
}

void TestBitmap::PushEnumToLua(lua_State *luaState) {
  lua_newtable(luaState);
  lua_pushstring(luaState, "Entry1");
  lua_pushnumber(luaState, TestBitmap::Entry1);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry1Index");
  lua_pushnumber(luaState, TestBitmap::Entry1Index);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry2");
  lua_pushnumber(luaState, TestBitmap::Entry2);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry2Index");
  lua_pushnumber(luaState, TestBitmap::Entry2Index);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry3");
  lua_pushnumber(luaState, TestBitmap::Entry3);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry3Index");
  lua_pushnumber(luaState, TestBitmap::Entry3Index);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry4");
  lua_pushnumber(luaState, TestBitmap::Entry4);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry4Index");
  lua_pushnumber(luaState, TestBitmap::Entry4Index);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry5");
  lua_pushnumber(luaState, TestBitmap::Entry5);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry5Index");
  lua_pushnumber(luaState, TestBitmap::Entry5Index);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Invalid");
  lua_pushnumber(luaState, 5);
  lua_settable(luaState, -3);
  lua_pushstring(luaState, "Entry1");
  lua_rawseti(luaState, -2, 0);
  lua_pushstring(luaState, "Entry2");
  lua_rawseti(luaState, -2, 1);
  lua_pushstring(luaState, "Entry3");
  lua_rawseti(luaState, -2, 2);
  lua_pushstring(luaState, "Entry4");
  lua_rawseti(luaState, -2, 3);
  lua_pushstring(luaState, "Entry5");
  lua_rawseti(luaState, -2, 4);
  lua_pushstring(luaState, "Invalid");
  lua_rawseti(luaState, -2, 5);
  lua_setglobal(luaState, "TestBitmap");
}
}
