// This file is generated by holgen. Do not modify manually.
#include "EnumTest.h"

namespace holgen_blackbox_csharp {
EnumTest::EnumTest(EnumTest::UnderlyingType value) :
    mValue(EnumTest::Entry(value)) {
}

EnumTest::EnumTest(Entry value) :
    mValue(value) {
}

EnumTest::Entry EnumTest::GetValue() const {
  return Entry(mValue);
}

EnumTest EnumTest::FromString(std::string_view str) {
  if (str == "Entry1") {
    return EnumTest(EnumTest::Entry1);
  } else if (str == "Entry2") {
    return EnumTest(EnumTest::Entry2);
  } else if (str == "Entry5") {
    return EnumTest(EnumTest::Entry5);
  } else {
    HOLGEN_WARN("{} is not a valid EnumTest, returning invalid", str);
    return EnumTest{EnumTest::Invalid};
  }
}

const char *EnumTest::ToString() const {
  switch (mValue) {
    case EnumTest::Entry1:
      return "Entry1";
    case EnumTest::Entry2:
      return "Entry2";
    case EnumTest::Entry5:
      return "Entry5";
    default:
      return "INVALID";
  }
}

EnumTest &EnumTest::operator=(UnderlyingType rhs) {
  mValue = EnumTest::Entry(rhs);
  return *this;
}

bool EnumTest::operator==(UnderlyingType rhs) const {
  return mValue == EnumTest::Entry(rhs);
}

bool EnumTest::operator==(const EnumTest &rhs) const {
  return mValue == rhs.mValue;
}

bool EnumTest::operator!=(UnderlyingType rhs) const {
  return mValue != EnumTest::Entry(rhs);
}

bool EnumTest::operator!=(const EnumTest &rhs) const {
  return mValue != rhs.mValue;
}

bool EnumTest::operator<(UnderlyingType rhs) const {
  return mValue < EnumTest::Entry(rhs);
}

bool EnumTest::operator<(const EnumTest &rhs) const {
  return mValue < rhs.mValue;
}
}
