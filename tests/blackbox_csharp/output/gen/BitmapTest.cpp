// This file is generated by holgen. Do not modify manually.
#include "BitmapTest.h"

#include <sstream>

namespace holgen_blackbox_csharp {
BitmapTest::BitmapTest(BitmapTest::UnderlyingType value) :
    mValue(UnderlyingType(value)) {
}

BitmapTest::UnderlyingType BitmapTest::GetValue() const {
  return mValue;
}

BitmapTest BitmapTest::FromStringSingle(std::string_view str) {
  if (str == "Entry1") {
    return BitmapTest(BitmapTest::Entry1);
  } else if (str == "Entry2") {
    return BitmapTest(BitmapTest::Entry2);
  } else if (str == "Entry5") {
    return BitmapTest(BitmapTest::Entry5);
  } else {
    HOLGEN_WARN("{} is not a valid BitmapTest, returning invalid", str);
    return BitmapTest{};
  }
}

BitmapTest BitmapTest::FromString(std::string_view str) {
  BitmapTest result;
  size_t curIdx = 0, commaIdx = str.find(',');
  while (commaIdx != std::string::npos) {
    result |= BitmapTest::FromStringSingle(str.substr(curIdx, commaIdx - curIdx));
    curIdx = commaIdx + 1;
    commaIdx = str.find(',', curIdx);
  }
  result |= BitmapTest::FromStringSingle(str.substr(curIdx));
  return result;
}

const char *BitmapTest::ToStringSingle() const {
  switch (mValue) {
    case BitmapTest::Entry1:
      return "Entry1";
    case BitmapTest::Entry2:
      return "Entry2";
    case BitmapTest::Entry5:
      return "Entry5";
    default:
      return "INVALID";
  }
}

std::string BitmapTest::ToString() const {
  std::stringstream ss;
  bool isFirst = true;
  for (auto& entry: GetEntries()) {
    if (Has(entry)) {
      if (isFirst) {
        isFirst = false;
      } else {
        ss << ",";
      }
      ss << BitmapTest(entry).ToStringSingle();
    }
  }
  return ss.str();
}

BitmapTest &BitmapTest::operator=(UnderlyingType rhs) {
  mValue = rhs;
  return *this;
}

bool BitmapTest::operator==(UnderlyingType rhs) const {
  return mValue == rhs;
}

bool BitmapTest::operator==(const BitmapTest &rhs) const {
  return mValue == rhs.mValue;
}

bool BitmapTest::operator!=(UnderlyingType rhs) const {
  return mValue != rhs;
}

bool BitmapTest::operator!=(const BitmapTest &rhs) const {
  return mValue != rhs.mValue;
}

bool BitmapTest::operator<(UnderlyingType rhs) const {
  return mValue < rhs;
}

bool BitmapTest::operator<(const BitmapTest &rhs) const {
  return mValue < rhs.mValue;
}

BitmapTest &BitmapTest::operator|=(BitmapTest::Entry rhs) {
  mValue |= rhs;
  return *this;
}

BitmapTest &BitmapTest::operator|=(const BitmapTest &rhs) {
  mValue |= rhs.mValue;
  return *this;
}

BitmapTest &BitmapTest::operator|=(UnderlyingType rhs) {
  mValue |= rhs;
  return *this;
}

bool BitmapTest::operator|(const BitmapTest &rhs) const {
  return mValue | rhs.mValue;
}

bool BitmapTest::operator|(BitmapTest::Entry rhs) const {
  return mValue | rhs;
}

BitmapTest &BitmapTest::operator&=(BitmapTest::Entry rhs) {
  mValue &= rhs;
  return *this;
}

BitmapTest &BitmapTest::operator&=(const BitmapTest &rhs) {
  mValue &= rhs.mValue;
  return *this;
}

BitmapTest &BitmapTest::operator&=(UnderlyingType rhs) {
  mValue &= rhs;
  return *this;
}

bool BitmapTest::operator&(const BitmapTest &rhs) const {
  return mValue & rhs.mValue;
}

bool BitmapTest::operator&(BitmapTest::Entry rhs) const {
  return mValue & rhs;
}

BitmapTest &BitmapTest::operator^=(BitmapTest::Entry rhs) {
  mValue ^= rhs;
  return *this;
}

BitmapTest &BitmapTest::operator^=(const BitmapTest &rhs) {
  mValue ^= rhs.mValue;
  return *this;
}

BitmapTest &BitmapTest::operator^=(UnderlyingType rhs) {
  mValue ^= rhs;
  return *this;
}

bool BitmapTest::operator^(const BitmapTest &rhs) const {
  return mValue ^ rhs.mValue;
}

bool BitmapTest::operator^(BitmapTest::Entry rhs) const {
  return mValue ^ rhs;
}

bool BitmapTest::Has(const BitmapTest &val) const {
  return (mValue & val.mValue) == val.mValue;
}

void BitmapTest::Add(const BitmapTest &val) {
  mValue |= val.mValue;
}

void BitmapTest::Remove(const BitmapTest &val) {
  mValue &= ~(val.mValue);
}

void BitmapTest::Toggle(const BitmapTest &val) {
  mValue ^= val.mValue;
}

bool BitmapTest::Has(const BitmapTest::Entry &val) const {
  return (mValue & val) == val;
}

void BitmapTest::Add(const BitmapTest::Entry &val) {
  mValue |= val;
}

void BitmapTest::Remove(const BitmapTest::Entry &val) {
  mValue &= ~(val);
}

void BitmapTest::Toggle(const BitmapTest::Entry &val) {
  mValue ^= val;
}
}
